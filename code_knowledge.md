**Пример-1:**

При изменении метода в суперклассе метод `makeSound()` исчез, но появился метод `makeGenericSound`. 
Однако, класс `Cat` всё ещё содержит метод `makeSound()` и при такой реализации он не переопределяет существующий метод, а создаёт новый метод, которого нет в родительском классе.

Потенциально это может приводить к скрытым ошибкам в логике и создаёт хрупкость в коде на основе зависимости одной сущности от другой.


**Пример-2:**

Данная программа отработает с ошибкой компиляции, т.к. в этом примере происходит перегрузка метода ввиду того, что он объявляется внутри одного класса дважды, при этом имея разную сигнатуру и функционал в целом.


**Пример-3:**

Комментарий в коде говорит о том, что существуют различные версии внешней зависимости для сущности `com.fasterxml.jackson.databind.ObjectMapper`.

При этом в проекте используются разные версии данной библиотеки, поведение которых может отличаться.

В этой ситуации код как бы "знает" про внутреннее устройство сущности из библиотеки `com.fasterxml.jackson.databind.ObjectMapper`, зависящее от конкретной версии, однако, при смене версии, которое может произойти не всегда под контролем разработчика, можно получить неконтролируемое поведение системы.

Так как реализация функции `findMax(arr)` осуществляет через цикл, то для доказательства сформулируем следующий инвариант цикла:

`I: 0 <= i <= n и result = max(arr[:i])` 

Реализация:

```python
def findMax(arr: list[int]) -> int:
    if len(arr) == 0:
        raise ValueError("Input list can't be empty")
    max_value = arr[0]
    for value in arr[1:]:
        if value > max_value:
            max_value = value
	return max_value
```

Доказательство инварианта:

1. **Инициализация**:  

До начала первой итерации цикла: `i = 1` и `result = max(arr[:1])`  
Инвариант истинен в начале, т.к. первое значение будет одновременно максимальным и единственным значением в массиве.

2. **Сохранение инварианта**:  

Предположим, что инвариант истинен до некоторой итерации цикла, где `1 <= i <= n` и 
`result = max(arr[:i])`.
Во время выполнения цикла: `result = arr[i] if arr[i] > result` и `i = i + 1`
После итерации значение `i` увеличивается на `1`, т.е. `i = i + 1`.
Следовательно, `result = arr[i] if arr[i] > arr[i-1]`
Таким образом, инвариант по-прежнему истинен: `0 <= i <= n` и `result = max(arr[:1])`

3. **Завершение**:  
Цикл завершается, когда `i` становится равным `n + 1`  
На этом этапе `result = max(arr[:n+1])`, так как инвариант после последней итерации: `i = n` и `result = max(arr[:n])`  
Следовательно, постусловие выполняется: `result = max(arr)`

Таким образом, доказано, что функция `findMax(arr)` корректно вычисляет максимальное значение в массиве.
